-- --------------------------------------------------------------------------
-- Hola y bienvenido al script de creaci√≥n de nuestro futuro imperio de e-commerce
-- Aqu√≠ se forja el esqueleto de la base de datos.
-- El orden es importante, as√≠ que no te pongas creativo y ejec√∫talo tal cual.
-- --------------------------------------------------------------------------

-- Limpieza previa (bot√≥n de autodestrucci√≥n , cuidadito wasauski)
/*
BEGIN
   FOR c IN (SELECT table_name FROM user_tables) LOOP
      EXECUTE IMMEDIATE 'DROP TABLE ' || c.table_name || ' CASCADE CONSTRAINTS';
   END LOOP;
END;
/
*/

-- --------------------------------------------------------------------------

-- Tabla TIENDAS.
CREATE TABLE tiendas (
    tienda_id           NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    nombre              VARCHAR2(100) NOT NULL,
    url_dominio         VARCHAR2(100),
    fecha_creacion      DATE DEFAULT SYSDATE NOT NULL,
    CONSTRAINT pk_tiendas PRIMARY KEY (tienda_id),
    CONSTRAINT uq_tiendas_nombre UNIQUE (nombre),
    CONSTRAINT uq_tiendas_url UNIQUE (url_dominio)
);
PROMPT Tabla TIENDAS creada.


CREATE TABLE roles (
    rol_id              NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    nombre_rol          VARCHAR2(50) NOT NULL,
    CONSTRAINT pk_roles PRIMARY KEY (rol_id),
    CONSTRAINT uq_roles_nombre UNIQUE (nombre_rol)
);
PROMPT Tabla ROLES creada.

-- --------------------------------------------------------------------------
-- Tabla USUARIOS.
CREATE TABLE usuarios (
    usuario_id          NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    tienda_id           NUMBER NOT NULL, -- Cada usuario pertenece a UNA tienda. No hay doble militancia.
    email               VARCHAR2(100) NOT NULL,
    password_hash       VARCHAR2(255) NOT NULL, -- Guardamos el hash, no la pass.
    nombre              VARCHAR2(50),
    apellido            VARCHAR2(50),
    fecha_registro      DATE DEFAULT SYSDATE NOT NULL,
    CONSTRAINT pk_usuarios PRIMARY KEY (usuario_id),
    CONSTRAINT fk_usuarios_tienda FOREIGN KEY (tienda_id) REFERENCES tiendas(tienda_id) ON DELETE CASCADE,
    CONSTRAINT uq_usuarios_email_tienda UNIQUE (tienda_id, email) -- El email debe ser √∫nico POR tienda.
);
PROMPT Tabla USUARIOS creada.

-- Tabla PRODUCTOS.
CREATE TABLE productos (
    producto_id         NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    tienda_id           NUMBER NOT NULL,
    nombre              VARCHAR2(255) NOT NULL,
    descripcion         CLOB, -- CLOB para descripciones largas, por si nos ponemos po√©ticos.
    precio              NUMBER(10, 2) NOT NULL,
    stock               NUMBER(9) DEFAULT 0 NOT NULL,
    sku                 VARCHAR2(50),
    CONSTRAINT pk_productos PRIMARY KEY (producto_id),
    CONSTRAINT fk_productos_tienda FOREIGN KEY (tienda_id) REFERENCES tiendas(tienda_id) ON DELETE CASCADE,
    CONSTRAINT chk_productos_precio CHECK (precio > 0), -- No vendemos cosas gratis, esto es un negocio ü§ë.
    CONSTRAINT chk_productos_stock CHECK (stock >= 0),
    CONSTRAINT uq_productos_sku_tienda UNIQUE (tienda_id, sku)
);
PROMPT Tabla PRODUCTOS creada.

-- --------------------------------------------------------------------------
-- Tabla USUARIOS_ROLES.
-- Esta tabla resuelve la relaci√≥n "Muchos a Muchos". Un usuario puede tener
-- varios roles, y un rol puede tener muchos usuarios. Sin ella, tendr√≠amos un enredo.
CREATE TABLE usuario_roles (
    usuario_id          NUMBER NOT NULL,
    rol_id              NUMBER NOT NULL,
    CONSTRAINT pk_usuario_roles PRIMARY KEY (usuario_id, rol_id),
    CONSTRAINT fk_usuarioroles_usuario FOREIGN KEY (usuario_id) REFERENCES usuarios(usuario_id) ON DELETE CASCADE,
    CONSTRAINT fk_usuarioroles_rol FOREIGN KEY (rol_id) REFERENCES roles(rol_id) ON DELETE CASCADE
);
PROMPT Tabla USUARIO_ROLES creada.

-- Tabla CATEGORIAS.
CREATE TABLE categorias (
    categoria_id        NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    tienda_id           NUMBER NOT NULL,
    nombre              VARCHAR2(100) NOT NULL,
    descripcion         CLOB,
    CONSTRAINT pk_categorias PRIMARY KEY (categoria_id),
    CONSTRAINT fk_categorias_tienda FOREIGN KEY (tienda_id) REFERENCES tiendas(tienda_id) ON DELETE CASCADE,
    CONSTRAINT uq_categorias_nombre_tienda UNIQUE (tienda_id, nombre)
);
PROMPT Tabla CATEGORIAS creada.

-- Tabla PRODUCTO_CATEGORIAS.
-- La misma l√≥gica que usuario_roles. Un producto puede estar en varias categor√≠as.
-- Esta tabla es la que nos permite tener una zapatilla en "Ofertas" y "Calzado de Verano".
CREATE TABLE producto_categorias (
    producto_id         NUMBER NOT NULL,
    categoria_id        NUMBER NOT NULL,
    CONSTRAINT pk_producto_categorias PRIMARY KEY (producto_id, categoria_id),
    CONSTRAINT fk_prodcat_producto FOREIGN KEY (producto_id) REFERENCES productos(producto_id) ON DELETE CASCADE,
    CONSTRAINT fk_prodcat_categoria FOREIGN KEY (categoria_id) REFERENCES categorias(categoria_id) ON DELETE CASCADE
);
PROMPT Tabla PRODUCTO_CATEGORIAS creada.

-- --------------------------------------------------------------------------
-- Tabla DIRECCIONES.
CREATE TABLE direcciones (
    direccion_id        NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    usuario_id          NUMBER NOT NULL,
    calle               VARCHAR2(255) NOT NULL,
    ciudad              VARCHAR2(100) NOT NULL,
    region              VARCHAR2(100),
    codigo_postal       VARCHAR2(20),
    pais                VARCHAR2(50) NOT NULL,
    CONSTRAINT pk_direcciones PRIMARY KEY (direccion_id),
    CONSTRAINT fk_direcciones_usuario FOREIGN KEY (usuario_id) REFERENCES usuarios(usuario_id) ON DELETE CASCADE
);
PROMPT Tabla DIRECCIONES creada.

-- Tabla PEDIDOS.
-- LA TABLA M√ÅS IMPORTANTE. Por eso la particionamos.
-- Particionarla por rango de fecha es como organizar un archivador por a√±o.
-- Cuando busquemos un pedido de 2025, Oracle ir√° directo a la carpeta "2025".
-- Inteligente, ¬øno? üßê
CREATE TABLE pedidos (
    pedido_id            NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    usuario_id           NUMBER NOT NULL,
    direccion_envio_id   NUMBER,
    fecha_pedido         DATE DEFAULT SYSDATE NOT NULL,
    estado               VARCHAR2(20) NOT NULL,
    total                NUMBER(12, 2) DEFAULT 0 NOT NULL,
    CONSTRAINT pk_pedidos PRIMARY KEY (pedido_id, fecha_pedido),
    CONSTRAINT fk_pedidos_usuario FOREIGN KEY (usuario_id) REFERENCES usuarios(usuario_id),
    CONSTRAINT fk_pedidos_direccion FOREIGN KEY (direccion_envio_id) REFERENCES direcciones(direccion_id) ON DELETE SET NULL,
    CONSTRAINT chk_pedidos_estado CHECK (estado IN ('PENDIENTE', 'PAGADO', 'ENVIADO', 'ENTREGADO', 'CANCELADO'))
)
PARTITION BY RANGE (fecha_pedido)
(
    PARTITION p_pedidos_2024 VALUES LESS THAN (TO_DATE('01-01-2025', 'DD-MM-YYYY')),
    PARTITION p_pedidos_2025 VALUES LESS THAN (TO_DATE('01-01-2026', 'DD-MM-YYYY')),
    PARTITION p_pedidos_max VALUES LESS THAN (MAXVALUE)
);
PROMPT Tabla PEDIDOS creada y particionada.

-- Tabla DETALLES_PEDIDO.
-- Esta tabla es el detalle de la boleta. Cada producto en un pedido es una fila aqu√≠.
-- As√≠, el pedido y sus detalles siempre estar√°n juntos. üíï
CREATE TABLE detalles_pedido (
    detalle_id          NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    pedido_id           NUMBER NOT NULL,
    fecha_pedido_fk     DATE NOT NULL,
    producto_id         NUMBER NOT NULL,
    cantidad            NUMBER(5) NOT NULL,
    precio_unitario     NUMBER(10, 2) NOT NULL, -- Guardamos el precio del momento de la compra. ¬°No hay estafas aqu√≠!
    CONSTRAINT pk_detalles_pedido PRIMARY KEY (detalle_id),
    CONSTRAINT fk_detalles_pedido_pedido FOREIGN KEY (pedido_id, fecha_pedido_fk) REFERENCES pedidos(pedido_id, fecha_pedido) ON DELETE CASCADE,
    CONSTRAINT fk_detalles_pedido_producto FOREIGN KEY (producto_id) REFERENCES productos(producto_id)
)
PARTITION BY REFERENCE (fk_detalles_pedido_pedido);
PROMPT Tabla DETALLES_PEDIDO creada y particionada por referencia.

-- Tabla PAGOS.
-- La misma l√≥gica que DETALLES_PEDIDO.
-- Si el pedido est√° en la partici√≥n de 2025, su pago tambi√©n.
CREATE TABLE pagos (
    pago_id             NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    pedido_id           NUMBER NOT NULL,
    fecha_pedido_fk     DATE NOT NULL,
    monto               NUMBER(12, 2) NOT NULL,
    fecha_pago          DATE DEFAULT SYSDATE NOT NULL,
    metodo_pago         VARCHAR2(50),
    estado_pago         VARCHAR2(20) NOT NULL,
    CONSTRAINT pk_pagos PRIMARY KEY (pago_id),
    CONSTRAINT uq_pagos_pedido UNIQUE (pedido_id, fecha_pedido_fk), -- Un pedido, un pago.
    CONSTRAINT fk_pagos_pedido FOREIGN KEY (pedido_id, fecha_pedido_fk) REFERENCES pedidos(pedido_id, fecha_pedido) ON DELETE CASCADE,
    CONSTRAINT chk_pagos_estado CHECK (estado_pago IN ('COMPLETADO', 'FALLIDO', 'REEMBOLSADO'))
)
PARTITION BY REFERENCE (fk_pagos_pedido);
PROMPT Tabla PAGOS creada y particionada por referencia.

PROMPT --- ü§ë ESTRUCTURA DE BASE DE DATOS CREADA EXITOSAMENTE ü§ë ---
