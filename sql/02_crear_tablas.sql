-- --------------------------------------------------------------------------
-- Hola y bienvenido al script de creaci√≥n de nuestro futuro imperio de e-commerce
-- Aqu√≠ se forja el esqueleto de la base de datos.
-- El orden es importante, as√≠ que no te pongas creativo y ejec√∫talo tal cual.
-- --------------------------------------------------------------------------

-- Limpieza previa (bot√≥n de autodestrucci√≥n , cuidadito wasauski)
/*
BEGIN
   FOR c IN (SELECT table_name FROM user_tables) LOOP
      EXECUTE IMMEDIATE 'DROP TABLE ' || c.table_name || ' CASCADE CONSTRAINTS';
   END LOOP;
END;
/
*/

-- --------------------------------------------------------------------------

-- Tabla TIENDAS.
CREATE TABLE tiendas (
    tienda_id           NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    nombre              VARCHAR2(100) NOT NULL,
    url_dominio         VARCHAR2(100),
    fecha_creacion      DATE DEFAULT SYSDATE NOT NULL,
    CONSTRAINT pk_tiendas PRIMARY KEY (tienda_id),
    CONSTRAINT uq_tiendas_nombre UNIQUE (nombre),
    CONSTRAINT uq_tiendas_url UNIQUE (url_dominio)
);
PROMPT Tabla TIENDAS creada.


CREATE TABLE roles (
    rol_id              NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    nombre_rol          VARCHAR2(50) NOT NULL,
    CONSTRAINT pk_roles PRIMARY KEY (rol_id),
    CONSTRAINT uq_roles_nombre UNIQUE (nombre_rol)
);
PROMPT Tabla ROLES creada.

-- --------------------------------------------------------------------------
-- Tabla USUARIOS.
CREATE TABLE usuarios (
    usuario_id          NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    tienda_id           NUMBER NOT NULL, -- Cada usuario pertenece a UNA tienda. No hay doble militancia.
    email               VARCHAR2(100) NOT NULL,
    password_hash       VARCHAR2(255) NOT NULL, -- Guardamos el hash, no la pass.
    nombre              VARCHAR2(50),
    apellido            VARCHAR2(50),
    fecha_registro      DATE DEFAULT SYSDATE NOT NULL,
    CONSTRAINT pk_usuarios PRIMARY KEY (usuario_id),
    CONSTRAINT fk_usuarios_tienda FOREIGN KEY (tienda_id) REFERENCES tiendas(tienda_id) ON DELETE CASCADE,
    CONSTRAINT uq_usuarios_email_tienda UNIQUE (tienda_id, email) -- El email debe ser √∫nico POR tienda.
);
PROMPT Tabla USUARIOS creada.

-- Tabla PRODUCTOS.
CREATE TABLE productos (
    producto_id         NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    tienda_id           NUMBER NOT NULL,
    nombre              VARCHAR2(255) NOT NULL,
    descripcion         CLOB, -- CLOB para descripciones largas, por si nos ponemos po√©ticos.
    precio              NUMBER(10, 2) NOT NULL,
    stock               NUMBER(9) DEFAULT 0 NOT NULL,
    sku                 VARCHAR2(50),
    CONSTRAINT pk_productos PRIMARY KEY (producto_id),
    CONSTRAINT fk_productos_tienda FOREIGN KEY (tienda_id) REFERENCES tiendas(tienda_id) ON DELETE CASCADE,
    CONSTRAINT chk_productos_precio CHECK (precio > 0), -- No vendemos cosas gratis, esto es un negocio ü§ë.
    CONSTRAINT chk_productos_stock CHECK (stock >= 0),
    CONSTRAINT uq_productos_sku_tienda UNIQUE (tienda_id, sku)
);
PROMPT Tabla PRODUCTOS creada.

-- --------------------------------------------------------------------------
-- Tabla USUARIOS_ROLES.
-- Esta tabla resuelve la relaci√≥n "Muchos a Muchos". Un usuario puede tener
-- varios roles, y un rol puede tener muchos usuarios. Sin ella, tendr√≠amos un enredo.
CREATE TABLE usuario_roles (
    usuario_id          NUMBER NOT NULL,
    rol_id              NUMBER NOT NULL,
    CONSTRAINT pk_usuario_roles PRIMARY KEY (usuario_id, rol_id),
    CONSTRAINT fk_usuarioroles_usuario FOREIGN KEY (usuario_id) REFERENCES usuarios(usuario_id) ON DELETE CASCADE,
    CONSTRAINT fk_usuarioroles_rol FOREIGN KEY (rol_id) REFERENCES roles(rol_id) ON DELETE CASCADE
);
PROMPT Tabla USUARIO_ROLES creada.

-- Tabla CATEGORIAS.
CREATE TABLE categorias (
    categoria_id        NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    tienda_id           NUMBER NOT NULL,
    nombre              VARCHAR2(100) NOT NULL,
    descripcion         CLOB,
    CONSTRAINT pk_categorias PRIMARY KEY (categoria_id),
    CONSTRAINT fk_categorias_tienda FOREIGN KEY (tienda_id) REFERENCES tiendas(tienda_id) ON DELETE CASCADE,
    CONSTRAINT uq_categorias_nombre_tienda UNIQUE (tienda_id, nombre)
);
PROMPT Tabla CATEGORIAS creada.

-- Tabla PRODUCTO_CATEGORIAS.
-- La misma l√≥gica que usuario_roles. Un producto puede estar en varias categor√≠as.
-- Esta tabla es la que nos permite tener una zapatilla en "Ofertas" y "Calzado de Verano".
CREATE TABLE producto_categorias (
    producto_id         NUMBER NOT NULL,
    categoria_id        NUMBER NOT NULL,
    CONSTRAINT pk_producto_categorias PRIMARY KEY (producto_id, categoria_id),
    CONSTRAINT fk_prodcat_producto FOREIGN KEY (producto_id) REFERENCES productos(producto_id) ON DELETE CASCADE,
    CONSTRAINT fk_prodcat_categoria FOREIGN KEY (categoria_id) REFERENCES categorias(categoria_id) ON DELETE CASCADE
);
PROMPT Tabla PRODUCTO_CATEGORIAS creada.

-- --------------------------------------------------------------------------
-- Tabla DIRECCIONES.
CREATE TABLE direcciones (
    direccion_id        NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    usuario_id          NUMBER NOT NULL,
    calle               VARCHAR2(255) NOT NULL,
    ciudad              VARCHAR2(100) NOT NULL,
    region              VARCHAR2(100),
    codigo_postal       VARCHAR2(20),
    pais                VARCHAR2(50) NOT NULL,
    CONSTRAINT pk_direcciones PRIMARY KEY (direccion_id),
    CONSTRAINT fk_direcciones_usuario FOREIGN KEY (usuario_id) REFERENCES usuarios(usuario_id) ON DELETE CASCADE
);
PROMPT Tabla DIRECCIONES creada.

-- Tabla PEDIDOS.
-- LA TABLA M√ÅS IMPORTANTE. Por eso la particionamos.
-- Particionarla por rango de fecha es como organizar un archivador por a√±o.
-- Cuando busquemos un pedido de 2025, Oracle ir√° directo a la carpeta "2025".
-- Inteligente, ¬øno? üßê
CREATE TABLE pedidos (
    pedido_id            NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    usuario_id           NUMBER NOT NULL,
    direccion_envio_id   NUMBER,
    fecha_pedido         DATE DEFAULT SYSDATE NOT NULL,
    estado               VARCHAR2(20) NOT NULL,
    total                NUMBER(12, 2) DEFAULT 0 NOT NULL,
    CONSTRAINT pk_pedidos PRIMARY KEY (pedido_id, fecha_pedido),
    CONSTRAINT fk_pedidos_usuario FOREIGN KEY (usuario_id) REFERENCES usuarios(usuario_id),
    CONSTRAINT fk_pedidos_direccion FOREIGN KEY (direccion_envio_id) REFERENCES direcciones(direccion_id) ON DELETE SET NULL,
    CONSTRAINT chk_pedidos_estado CHECK (estado IN ('PENDIENTE', 'PAGADO', 'ENVIADO', 'ENTREGADO', 'CANCELADO'))
)
PARTITION BY RANGE (fecha_pedido)
(
    PARTITION p_pedidos_2024 VALUES LESS THAN (TO_DATE('01-01-2025', 'DD-MM-YYYY')),
    PARTITION p_pedidos_2025 VALUES LESS THAN (TO_DATE('01-01-2026', 'DD-MM-YYYY')),
    PARTITION p_pedidos_max VALUES LESS THAN (MAXVALUE)
);
PROMPT Tabla PEDIDOS creada y particionada.

-- Tabla DETALLES_PEDIDO.
-- Esta tabla es el detalle de la boleta. Cada producto en un pedido es una fila aqu√≠.
-- As√≠, el pedido y sus detalles siempre estar√°n juntos. üíï
CREATE TABLE detalles_pedido (
    detalle_id          NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    pedido_id           NUMBER NOT NULL,
    fecha_pedido_fk     DATE NOT NULL,
    producto_id         NUMBER NOT NULL,
    cantidad            NUMBER(5) NOT NULL,
    precio_unitario     NUMBER(10, 2) NOT NULL, -- Guardamos el precio del momento de la compra. ¬°No hay estafas aqu√≠! üòà
    CONSTRAINT pk_detalles_pedido PRIMARY KEY (detalle_id),
    CONSTRAINT fk_detalles_pedido_pedido FOREIGN KEY (pedido_id, fecha_pedido_fk) REFERENCES pedidos(pedido_id, fecha_pedido) ON DELETE CASCADE,
    CONSTRAINT fk_detalles_pedido_producto FOREIGN KEY (producto_id) REFERENCES productos(producto_id)
)
PARTITION BY REFERENCE (fk_detalles_pedido_pedido);
PROMPT Tabla DETALLES_PEDIDO creada y particionada por referencia.

-- Tabla PAGOS.
-- La misma l√≥gica que DETALLES_PEDIDO.
-- Si el pedido est√° en la partici√≥n de 2025, su pago tambi√©n.
CREATE TABLE pagos (
    pago_id             NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    pedido_id           NUMBER NOT NULL,
    fecha_pedido_fk     DATE NOT NULL,
    monto               NUMBER(12, 2) NOT NULL,
    fecha_pago          DATE DEFAULT SYSDATE NOT NULL,
    metodo_pago         VARCHAR2(50),
    estado_pago         VARCHAR2(20) NOT NULL,
    CONSTRAINT pk_pagos PRIMARY KEY (pago_id),
    CONSTRAINT uq_pagos_pedido UNIQUE (pedido_id, fecha_pedido_fk), -- Un pedido, un pago.
    CONSTRAINT fk_pagos_pedido FOREIGN KEY (pedido_id, fecha_pedido_fk) REFERENCES pedidos(pedido_id, fecha_pedido) ON DELETE CASCADE,
    CONSTRAINT chk_pagos_estado CHECK (estado_pago IN ('COMPLETADO', 'FALLIDO', 'REEMBOLSADO'))
)
PARTITION BY REFERENCE (fk_pagos_pedido);
PROMPT Tabla PAGOS creada y particionada por referencia.

-- DATA WAREHOUSE
-- Aqu√≠ es donde los datos se convierten en GOLD üí∞ 

-- Creacion de la tabla dimensional de tiempo
CREATE TABLE Dim_Tiempo (
    fecha_id         NUMBER PRIMARY KEY,
    fecha            DATE,
    dia              NUMBER,
    mes              NUMBER,
    a√±o              NUMBER,
    trimestre        NUMBER,
    nombre_mes       VARCHAR2(20),
    dia_semana       VARCHAR2(15)
);

PROMPT Dimension de tiempo creada con exito

-- Creacion de la tabla dimensional de producto
CREATE TABLE Dim_Producto (
    producto_id      NUMBER PRIMARY KEY,
    nombre           VARCHAR2(255),
    descripcion      CLOB,
    precio           NUMBER(10,2),
    sku              VARCHAR2(50)
);

PROMPT Dimension de producto creada con exito

-- Creacion de la tabla dimensional de usuario
CREATE TABLE Dim_Usuario (
    usuario_id       NUMBER PRIMARY KEY,
    nombre           VARCHAR2(50),
    apellido         VARCHAR2(50),
    email            VARCHAR2(100),
    tienda_id        NUMBER
);

PROMPT Dimension de usuario creada con exito

-- Creacion de la tabla dimensional de tienda
CREATE TABLE Dim_Tienda (
    tienda_id        NUMBER PRIMARY KEY,
    nombre           VARCHAR2(100),
    url_dominio      VARCHAR2(100),
    fecha_creacion   DATE
);

PROMPT Dimension de tienda creada con exito

--Creacion de tabla de hechos de ventas
CREATE TABLE Hecho_Ventas (
    id_venta         NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    fecha_id         NUMBER NOT NULL,
    producto_id      NUMBER NOT NULL,
    usuario_id       NUMBER NOT NULL,
    tienda_id        NUMBER NOT NULL,
    cantidad         NUMBER,
    precio_unitario  NUMBER(10,2),
    total_venta      NUMBER(12,2),
    -- Foreign Keys hacia las dimensiones
    CONSTRAINT fk_hv_tiempo    FOREIGN KEY (fecha_id)    REFERENCES Dim_Tiempo(fecha_id),
    CONSTRAINT fk_hv_producto  FOREIGN KEY (producto_id)  REFERENCES Dim_Producto(producto_id),
    CONSTRAINT fk_hv_usuario   FOREIGN KEY (usuario_id)   REFERENCES Dim_Usuario(usuario_id),
    CONSTRAINT fk_hv_tienda    FOREIGN KEY (tienda_id)    REFERENCES Dim_Tienda(tienda_id)
)
PARTITION BY RANGE (fecha_id)
(
    PARTITION p_2024 VALUES LESS THAN (TO_DATE('01-01-2025', 'DD-MM-YYYY')),
    PARTITION p_2025 VALUES LESS THAN (TO_DATE('01-01-2026', 'DD-MM-YYYY')),
    PARTITION p_2026 VALUES LESS THAN (TO_DATE('01-01-2027', 'DD-MM-YYYY')),
    PARTITION p_max  VALUES LESS THAN (MAXVALUE)
);

PROMPT FACTOSSS DE VENTAS CREADOS CON √âXITO ü§ë



-- Se crea la tabla de auditor√≠a
-- Esta tabla registra todas las operaciones de INSERT, UPDATE y DELETE en las tablas principales.
CREATE TABLE tabla_auditoria (
    auditoria_id        NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    nombre_tabla        VARCHAR2(100) NOT NULL,
    tipo_operacion      VARCHAR2(10) NOT NULL, -- 'INSERT', 'UPDATE', 'DELETE'
    registro_id         NUMBER,               -- ID de la fila afectada en la tabla original
    valores_antiguos    CLOB,                 -- Valores de la fila antes del cambio (para UPDATE/DELETE)
    valores_nuevos      CLOB,                 -- Valores de la fila despu√©s del cambio (para INSERT/UPDATE)
    usuario_accion      VARCHAR2(100) DEFAULT USER NOT NULL, -- Usuario que realiz√≥ la acci√≥n
    fecha_accion        DATE DEFAULT SYSDATE NOT NULL,      -- Marca de tiempo de la acci√≥n
    CONSTRAINT pk_tabla_auditoria PRIMARY KEY (auditoria_id),
    CONSTRAINT chk_tipo_operacion CHECK (tipo_operacion IN ('INSERT', 'UPDATE', 'DELETE'))
)
PARTITION BY RANGE (fecha_accion)
(
    PARTITION p_2024 VALUES LESS THAN (TO_DATE('01-01-2025', 'DD-MM-YYYY')),
    PARTITION p_2025 VALUES LESS THAN (TO_DATE('01-01-2026', 'DD-MM-YYYY')),
    PARTITION p_2026 VALUES LESS THAN (TO_DATE('01-01-2027', 'DD-MM-YYYY')),
    PARTITION p_max  VALUES LESS THAN (MAXVALUE)
);

PROMPT se crea la tabla auditoria, de aqui vigilamo toh. corte 1984, su gran hermanito


--trigger para ingresar datos de la tabla tiendas a la tabla auditoria
CREATE OR REPLACE TRIGGER trg_tiendas_audit
AFTER INSERT OR UPDATE OR DELETE ON tiendas
FOR EACH ROW
DECLARE
    v_old_values CLOB;
    v_new_values CLOB;
BEGIN
    IF INSERTING THEN
        -- Para INSERT, los valores antiguos son nulos, los nuevos son los insertados
        v_new_values := 'tienda_id: ' || :NEW.tienda_id ||
                        ' | nombre: ' || :NEW.nombre ||
                        ' | url_dominio: ' || :NEW.url_dominio ||
                        ' | fecha_creacion: ' || TO_CHAR(:NEW.fecha_creacion, 'YYYY-MM-DD HH24:MI:SS');
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('tiendas', 'INSERT', :NEW.tienda_id, v_new_values, USER, SYSDATE);
    ELSIF UPDATING THEN
        -- Para UPDATE, se registran los valores antiguos y los nuevos
        v_old_values := 'tienda_id: ' || :OLD.tienda_id ||
                        ' | nombre: ' || :OLD.nombre ||
                        ' | url_dominio: ' || :OLD.url_dominio ||
                        ' | fecha_creacion: ' || TO_CHAR(:OLD.fecha_creacion, 'YYYY-MM-DD HH24:MI:SS');
        v_new_values := 'tienda_id: ' || :NEW.tienda_id ||
                        ' | nombre: ' || :NEW.nombre ||
                        ' | url_dominio: ' || :NEW.url_dominio ||
                        ' | fecha_creacion: ' || TO_CHAR(:NEW.fecha_creacion, 'YYYY-MM-DD HH24:MI:SS');
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('tiendas', 'UPDATE', :NEW.tienda_id, v_old_values, v_new_values, USER, SYSDATE);
    ELSIF DELETING THEN
        -- Para DELETE, solo se registran los valores antiguos (los que fueron eliminados)
        v_old_values := 'tienda_id: ' || :OLD.tienda_id ||
                        ' | nombre: ' || :OLD.nombre ||
                        ' | url_dominio: ' || :OLD.url_dominio ||
                        ' | fecha_creacion: ' || TO_CHAR(:OLD.fecha_creacion, 'YYYY-MM-DD HH24:MI:SS');
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, usuario_accion, fecha_accion)
        VALUES ('tiendas', 'DELETE', :OLD.tienda_id, v_old_values, USER, SYSDATE);
    END IF;
END;
/

PROMPT primer trigger de auditoria creado (tabla tiendas)

-- Trigger para registrar auditor√≠a de la tabla USUARIOS
CREATE OR REPLACE TRIGGER trg_usuarios_audit
AFTER INSERT OR UPDATE OR DELETE ON usuarios
FOR EACH ROW
DECLARE
    v_old_values CLOB;
    v_new_values CLOB;
BEGIN
    IF INSERTING THEN
        v_new_values := 'usuario_id: ' || :NEW.usuario_id ||
                        ' | tienda_id: ' || :NEW.tienda_id ||
                        ' | email: ' || :NEW.email ||
                        ' | nombre: ' || :NEW.nombre ||
                        ' | apellido: ' || :NEW.apellido ||
                        ' | fecha_registro: ' || TO_CHAR(:NEW.fecha_registro, 'YYYY-MM-DD HH24:MI:SS');
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('usuarios', 'INSERT', :NEW.usuario_id, v_new_values, USER, SYSDATE);
    ELSIF UPDATING THEN
        v_old_values := 'usuario_id: ' || :OLD.usuario_id ||
                        ' | tienda_id: ' || :OLD.tienda_id ||
                        ' | email: ' || :OLD.email ||
                        ' | password_hash: ' || :OLD.password_hash ||
                        ' | nombre: ' || :OLD.nombre ||
                        ' | apellido: ' || :OLD.apellido ||
                        ' | fecha_registro: ' || TO_CHAR(:OLD.fecha_registro, 'YYYY-MM-DD HH24:MI:SS');
        v_new_values := 'usuario_id: ' || :NEW.usuario_id ||
                        ' | tienda_id: ' || :NEW.tienda_id ||
                        ' | email: ' || :NEW.email ||
                        ' | password_hash: ' || :NEW.password_hash ||
                        ' | nombre: ' || :NEW.nombre ||
                        ' | apellido: ' || :NEW.apellido ||
                        ' | fecha_registro: ' || TO_CHAR(:NEW.fecha_registro, 'YYYY-MM-DD HH24:MI:SS');
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('usuarios', 'UPDATE', :NEW.usuario_id, v_old_values, v_new_values, USER, SYSDATE);
    ELSIF DELETING THEN
        v_old_values := 'usuario_id: ' || :OLD.usuario_id ||
                        ' | tienda_id: ' || :OLD.tienda_id ||
                        ' | email: ' || :OLD.email ||
                        ' | nombre: ' || :OLD.nombre ||
                        ' | apellido: ' || :OLD.apellido ||
                        ' | fecha_registro: ' || TO_CHAR(:OLD.fecha_registro, 'YYYY-MM-DD HH24:MI:SS');
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, usuario_accion, fecha_accion)
        VALUES ('usuarios', 'DELETE', :OLD.usuario_id, v_old_values, USER, SYSDATE);
    END IF;
END;
/

PROMPT Segundo trigger de auditoria creado (tabla usuarios) üòî

-- Trigger para registrar auditor√≠a de la tabla PRODUCTOS
CREATE OR REPLACE TRIGGER trg_productos_audit
AFTER INSERT OR UPDATE OR DELETE ON productos
FOR EACH ROW
DECLARE
    v_old_values CLOB;
    v_new_values CLOB;
BEGIN
    IF INSERTING THEN
        v_new_values := 'producto_id: ' || :NEW.producto_id ||
                        ' | tienda_id: ' || :NEW.tienda_id ||
                        ' | nombre: ' || :NEW.nombre ||
                        ' | descripcion: ' || :NEW.descripcion ||
                        ' | precio: ' || :NEW.precio ||
                        ' | stock: ' || :NEW.stock ||
                        ' | sku: ' || :NEW.sku;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('productos', 'INSERT', :NEW.producto_id, v_new_values, USER, SYSDATE);
    ELSIF UPDATING THEN
        v_old_values := 'producto_id: ' || :OLD.producto_id ||
                        ' | tienda_id: ' || :OLD.tienda_id ||
                        ' | nombre: ' || :OLD.nombre ||
                        ' | descripcion: ' || :OLD.descripcion ||
                        ' | precio: ' || :OLD.precio ||
                        ' | stock: ' || :OLD.stock ||
                        ' | sku: ' || :OLD.sku;
        v_new_values := 'producto_id: ' || :NEW.producto_id ||
                        ' | tienda_id: ' || :NEW.tienda_id ||
                        ' | nombre: ' || :NEW.nombre ||
                        ' | descripcion: ' || :NEW.descripcion ||
                        ' | precio: ' || :NEW.precio ||
                        ' | stock: ' || :NEW.stock ||
                        ' | sku: ' || :NEW.sku;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('productos', 'UPDATE', :NEW.producto_id, v_old_values, v_new_values, USER, SYSDATE);
    ELSIF DELETING THEN
        v_old_values := 'producto_id: ' || :OLD.producto_id ||
                        ' | tienda_id: ' || :OLD.tienda_id ||
                        ' | nombre: ' || :OLD.nombre ||
                        ' | descripcion: ' || :OLD.descripcion ||
                        ' | precio: ' || :OLD.precio ||
                        ' | stock: ' || :OLD.stock ||
                        ' | sku: ' || :OLD.sku;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, usuario_accion, fecha_accion)
        VALUES ('productos', 'DELETE', :OLD.producto_id, v_old_values, USER, SYSDATE);
    END IF;
END;
/

PROMPT Tercer trigger de auditoria creado (tabla productos) üòü

-- Trigger para registrar auditor√≠a de la tabla PEDIDOS
CREATE OR REPLACE TRIGGER trg_pedidos_audit
AFTER INSERT OR UPDATE OR DELETE ON pedidos
FOR EACH ROW
DECLARE
    v_old_values CLOB;
    v_new_values CLOB;
BEGIN
    IF INSERTING THEN
        v_new_values := 'pedido_id: ' || :NEW.pedido_id ||
                        ' | usuario_id: ' || :NEW.usuario_id ||
                        ' | direccion_envio_id: ' || :NEW.direccion_envio_id ||
                        ' | fecha_pedido: ' || TO_CHAR(:NEW.fecha_pedido, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | estado: ' || :NEW.estado ||
                        ' | total: ' || :NEW.total;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('pedidos', 'INSERT', :NEW.pedido_id, v_new_values, USER, SYSDATE);
    ELSIF UPDATING THEN
        v_old_values := 'pedido_id: ' || :OLD.pedido_id ||
                        ' | usuario_id: ' || :OLD.usuario_id ||
                        ' | direccion_envio_id: ' || :OLD.direccion_envio_id ||
                        ' | fecha_pedido: ' || TO_CHAR(:OLD.fecha_pedido, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | estado: ' || :OLD.estado ||
                        ' | total: ' || :OLD.total;
        v_new_values := 'pedido_id: ' || :NEW.pedido_id ||
                        ' | usuario_id: ' || :NEW.usuario_id ||
                        ' | direccion_envio_id: ' || :NEW.direccion_envio_id ||
                        ' | fecha_pedido: ' || TO_CHAR(:NEW.fecha_pedido, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | estado: ' || :NEW.estado ||
                        ' | total: ' || :NEW.total;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('pedidos', 'UPDATE', :NEW.pedido_id, v_old_values, v_new_values, USER, SYSDATE);
    ELSIF DELETING THEN
        v_old_values := 'pedido_id: ' || :OLD.pedido_id ||
                        ' | usuario_id: ' || :OLD.usuario_id ||
                        ' | direccion_envio_id: ' || :OLD.direccion_envio_id ||
                        ' | fecha_pedido: ' || TO_CHAR(:OLD.fecha_pedido, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | estado: ' || :OLD.estado ||
                        ' | total: ' || :OLD.total;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, usuario_accion, fecha_accion)
        VALUES ('pedidos', 'DELETE', :OLD.pedido_id, v_old_values, USER, SYSDATE);
    END IF;
END;
/

PROMPT Cuarto trigger de auditoria creado (tabla pedidos) ü•≤


-- Trigger para registrar auditor√≠a de la tabla DETALLES_PEDIDO
CREATE OR REPLACE TRIGGER trg_detalles_pedido_audit
AFTER INSERT OR UPDATE OR DELETE ON detalles_pedido
FOR EACH ROW
DECLARE
    v_old_values CLOB;
    v_new_values CLOB;
BEGIN
    IF INSERTING THEN
        v_new_values := 'detalle_id: ' || :NEW.detalle_id ||
                        ' | pedido_id: ' || :NEW.pedido_id ||
                        ' | fecha_pedido_fk: ' || TO_CHAR(:NEW.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | producto_id: ' || :NEW.producto_id ||
                        ' | cantidad: ' || :NEW.cantidad ||
                        ' | precio_unitario: ' || :NEW.precio_unitario;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('detalles_pedido', 'INSERT', :NEW.detalle_id, v_new_values, USER, SYSDATE);
    ELSIF UPDATING THEN
        v_old_values := 'detalle_id: ' || :OLD.detalle_id ||
                        ' | pedido_id: ' || :OLD.pedido_id ||
                        ' | fecha_pedido_fk: ' || TO_CHAR(:OLD.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | producto_id: ' || :OLD.producto_id ||
                        ' | cantidad: ' || :OLD.cantidad ||
                        ' | precio_unitario: ' || :OLD.precio_unitario;
        v_new_values := 'detalle_id: ' || :NEW.detalle_id ||
                        ' | pedido_id: ' || :NEW.pedido_id ||
                        ' | fecha_pedido_fk: ' || TO_CHAR(:NEW.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | producto_id: ' || :NEW.producto_id ||
                        ' | cantidad: ' || :NEW.cantidad ||
                        ' | precio_unitario: ' || :NEW.precio_unitario;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('detalles_pedido', 'UPDATE', :NEW.detalle_id, v_old_values, v_new_values, USER, SYSDATE);
    ELSIF DELETING THEN
        v_old_values := 'detalle_id: ' || :OLD.detalle_id ||
                        ' | pedido_id: ' || :OLD.pedido_id ||
                        ' | fecha_pedido_fk: ' || TO_CHAR(:OLD.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | producto_id: ' || :OLD.producto_id ||
                        ' | cantidad: ' || :OLD.cantidad ||
                        ' | precio_unitario: ' || :OLD.precio_unitario;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, usuario_accion, fecha_accion)
        VALUES ('detalles_pedido', 'DELETE', :OLD.detalle_id, v_old_values, USER, SYSDATE);
    END IF;
END;
/

PROMPT Quinto trigger de auditoria creado (tabla detalles_pedido) üò≠üî´

-- Trigger para registrar auditor√≠a de la tabla PAGOS
CREATE OR REPLACE TRIGGER trg_pagos_audit
AFTER INSERT OR UPDATE OR DELETE ON pagos
FOR EACH ROW
DECLARE
    v_old_values CLOB;
    v_new_values CLOB;
BEGIN
    IF INSERTING THEN
        v_new_values := 'pago_id: ' || :NEW.pago_id ||
                        ' | pedido_id: ' || :NEW.pedido_id ||
                        ' | fecha_pedido_fk: ' || TO_CHAR(:NEW.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | monto: ' || :NEW.monto ||
                        ' | fecha_pago: ' || TO_CHAR(:NEW.fecha_pago, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | metodo_pago: ' || :NEW.metodo_pago ||
                        ' | estado_pago: ' || :NEW.estado_pago;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('pagos', 'INSERT', :NEW.pago_id, v_new_values, USER, SYSDATE);
    ELSIF UPDATING THEN
        v_old_values := 'pago_id: ' || :OLD.pago_id ||
                        ' | pedido_id: ' || :OLD.pedido_id ||
                        ' | fecha_pedido_fk: ' || TO_CHAR(:OLD.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | monto: ' || :OLD.monto ||
                        ' | fecha_pago: ' || TO_CHAR(:OLD.fecha_pago, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | metodo_pago: ' || :OLD.metodo_pago ||
                        ' | estado_pago: ' || :OLD.estado_pago;
        v_new_values := 'pago_id: ' || :NEW.pago_id ||
                        ' | pedido_id: ' || :NEW.pedido_id ||
                        ' | fecha_pedido_fk: ' || TO_CHAR(:NEW.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | monto: ' || :NEW.monto ||
                        ' | fecha_pago: ' || TO_CHAR(:NEW.fecha_pago, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | metodo_pago: ' || :NEW.metodo_pago ||
                        ' | estado_pago: ' || :NEW.estado_pago;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, valores_nuevos, usuario_accion, fecha_accion)
        VALUES ('pagos', 'UPDATE', :NEW.pago_id, v_old_values, v_new_values, USER, SYSDATE);
    ELSIF DELETING THEN
        v_old_values := 'pago_id: ' || :OLD.pago_id ||
                        ' | pedido_id: ' || :OLD.pedido_id ||
                        ' | fecha_pedido_fk: ' || TO_CHAR(:OLD.fecha_pedido_fk, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | monto: ' || :OLD.monto ||
                        ' | fecha_pago: ' || TO_CHAR(:OLD.fecha_pago, 'YYYY-MM-DD HH24:MI:SS') ||
                        ' | metodo_pago: ' || :OLD.metodo_pago ||
                        ' | estado_pago: ' || :OLD.estado_pago;
        INSERT INTO tabla_auditoria (nombre_tabla, tipo_operacion, registro_id, valores_antiguos, usuario_accion, fecha_accion)
        VALUES ('pagos', 'DELETE', :OLD.pago_id, v_old_values, USER, SYSDATE);
    END IF;
END;
/

PROMPT Sexto trigger de auditoria creado (tabla pagos) üíÄ

PROMPT --- ü§ë ESTRUCTURA DE BASE DE DATOS CREADA EXITOSAMENTE ü§ë ---
